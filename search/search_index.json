{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#software-evolution","title":"Software Evolution","text":"<p>Software tends to grow larger and larger. Even the small pet projects may end as the huge monsters. Software growth imposes new challenges:</p> <ul> <li>Large amounts of code are hard to test and maintain.</li> <li>Software is complex. Only small amount of functions is    necessary for the single users' task. But all of them are present   and consume the memory. Large amount of unused functions   affect application load time.</li> <li>Software should be extendable. Users would add the new functions   to tie software to their needs. Third-party developers should offer   the packs of the new functions.  </li> </ul> <p>Software developers adopted the modular approach decades ago. Functions may be groupped into larger units, called the modules. Sometimes, the modules form the groups, when each member of  group interacts with the rest of application in similar way. The way of interaction is the interface. Interfaces are the barriers, separating parts of applications from each other. Each side of application may realize the part over the barries as the black box. Internals of the black box doesn't matter all all. Only the interface matters.</p> <p>The breaktrough is the fact that such black boxes are changeable. Black box must perform some kind of function, regardless of implementation and of the final result. Just replace the box with another one and application will act differently. Black boxes is relatilevy small and observable and may be tested as the independed entity.</p> <p>So the software may be designed as the orchestration core, which communnicates and distributes the tasks to the black boxes, leaving all the complexity and the dirty job to them.</p> <p>We'd got rid of the complexity and the application may be extended in relatively easy way. But how to use only boxes necessary for the user's taks? How to replace the boxes? How to add the own ones?</p> <p>Computer software industry has developed a mighty spell. Let's shout it: PLUGINS.</p>"},{"location":"#plugins","title":"Plugins","text":"<p>Plugins are modules, sharing common interface and dedicated to particular kind of tasks. Developers may pack plugins along with application or distribute them as the separate packs.</p>"},{"location":"#the-loader","title":"The Loader","text":"<p>Gufo Loader is the simple Python library supplied with the best practices. Loader managed the Python plugins lifecycle in the clean and sound way. Application core may use the Loader to enumerate and load the plugins.</p> <p>Depending on the requirements, Plugins may be:</p> <ul> <li>Subclasses of the given class.</li> <li>Classes sharing the protocol.</li> <li>Singleton instances of the given class.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Clean dict-like API.</li> <li>Full abstraction from the plugin internals.</li> <li>Custom plugins.</li> <li>Built with security in mind.</li> <li>Full Python typing support.</li> <li>Editor completion.</li> <li>Well-tested, battle-proven code.</li> <li>100% test coverage.</li> </ul>"},{"location":"#on-gufo-stack","title":"On Gufo Stack","text":"<p>This product is a part of Gufo Stack - the collaborative effort  led by Gufo Labs. Our goal is to create a robust and flexible  set of tools to create network management software and automate  routine administration tasks.</p> <p>To do this, we extract the key technologies that have proven themselves  in the NOC and bring them as separate packages. Then we work on API, performance tuning, documentation, and testing. The NOC uses the final result as the external dependencies.</p> <p>Gufo Stack makes the NOC better, and this is our primary task. But other products can benefit from Gufo Stack too. So we believe that our effort will make  the other network management products better.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p> <p>To see unreleased changes, please see the CHANGELOG on the master branch guide.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Python 3.14 support.</li> </ul>"},{"location":"CHANGELOG/#security","title":"Security","text":"<ul> <li>Install security updates during devcontainer build.</li> </ul>"},{"location":"CHANGELOG/#infrastructure","title":"Infrastructure","text":"<ul> <li>Use python:3.14-slim-trixie as base for devcontainer.</li> <li>Codecov integration.</li> <li>Ruff 0.14.0</li> <li>Mypy 1.18.2</li> <li>Pytest 8.4.2</li> <li>IPython 9.6.0</li> </ul>"},{"location":"CHANGELOG/#104-2025-08-24","title":"1.0.4 - 2025-08-24","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Python 3.13 support.</li> <li>docs: Fancy front page.</li> </ul>"},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>Protocol scheme documentation and examples.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Dropping Python 3.8 support</li> </ul>"},{"location":"CHANGELOG/#infrastructure_1","title":"Infrastructure","text":"<ul> <li>Depencies are moved to pyproject.toml</li> <li>devcontainer: Move settings to <code>customizations.vscode.settings</code></li> <li>devcontainer: Python 3.13</li> <li>Ruff 0.11.2</li> <li>mypy 1.13.0</li> <li>mkdocs-material 9.5.44</li> <li>pytest 8.3.3</li> <li>coverage 7.6.4</li> <li>IPython 9.4.0</li> </ul>"},{"location":"CHANGELOG/#103-2022-02-06","title":"1.0.3 - 2022-02-06","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li><code>py.typed</code> file for PEP-561 compatibility</li> <li>docs: Supported standards</li> <li>Loader.iter() method.</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>docs: license.md renamed to LICENSE.md</li> </ul>"},{"location":"CHANGELOG/#infrastructure_2","title":"Infrastructure","text":"<ul> <li>Adopt ruff</li> <li>Use <code>actions/checkout@v3</code></li> <li>Use <code>actions/cache@v3</code></li> <li>Project structure tests</li> <li>CI workflows tests</li> <li>Extend licence copyright years</li> <li>Dockerfile: Use <code>set -x</code> to log RUN commands</li> <li>docs: Use common Gufo Labs mkdocs plugins set</li> </ul>"},{"location":"CHANGELOG/#102-2022-11-06","title":"1.0.2 - 2022-11-06","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Python 3.11 support</li> <li>Add CITATION.cff</li> <li>Developer's Common Tasks</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Move CHANGELOG.md to the project root</li> </ul>"},{"location":"CHANGELOG/#infrastructure_3","title":"Infrastructure","text":"<ul> <li>Use Python 3.11 for dev container</li> <li>Use mkdocs-material 3.5.8</li> <li>Use pytest 7.2.0</li> <li>Use python-coverage 6.5.0</li> </ul>"},{"location":"CHANGELOG/#101-2022-04-15","title":"1.0.1 - 2022-04-15","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li><code>__version__</code> attribute.</li> </ul>"},{"location":"CHANGELOG/#100-2022-03-03","title":"1.0.0 - 2022-03-03","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Initial implementation.</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2022-2025, Gufo Labs. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li>Redistributions of source code must retain the above copyright notice,    this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</li> <li>Neither the name of Gufo Labs nor the names of its contributors may be used    to endorse or promote products derived from this software without    specific prior written permission.</li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"faq/","title":"FAQ","text":"<p>What is \"Gufo\"?</p> <p>Gufo means the Owl in Italian.</p> <p>Why the owls?</p> <p>We love owls and the viable parts of our technologies were proven at the project, named \"the Owl\".</p> <p>What is \"Gufo Labs\"?</p> <p>Gufo Labs is the Milan-based company specialized on network and IT consulting, and on software research.</p> <p>What is \"Gufo Stack\"?</p> <p>We've extracted core components behind the NOC  and released them as independent packages, available under the terms  of the 3-clause BSD license. Our software shares common code quality standards  and is battle-proven under the high load. We hope our key components will help  the engineers and the developers to build reliable networks and robust network  management software.  See more for details.</p> <p>Why I shouldn't use the plain <code>__import__</code> function?</p> <p>You can use <code>__import__</code> function, but you need to add a boilerplate code to find the real plugin implementation. Also, you need some kind of wrapping to settle the type hinting. And you need to reimplement it again and again in every new project. Consider the Gufo Loader as the library and the methodology, based on best practices.</p> <p>How can I load and initialize all plugins on startup?</p> <p>Loader.values() and  Loader.items() are import the modules and perform all plugins initialization. So just wrap them in the list:</p> <pre><code>list(loader.values())\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Install with the pip</p> <pre><code>$ pip install gufo_loader\n</code></pre>"},{"location":"installation/#checking-the-installation","title":"Checking the Installation","text":"<p>To check the installation just import the module</p> <pre><code>from gufo.loader import Loader\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade existing Gufo Loader installation use pip</p> <pre><code>$ pip install --upgrade gufo_loader\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<p>To uninstall Gufo Loader use pip</p> <pre><code>$ pip uninstall gufo_loader\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Generic Python class loader for robust plugin infrastructure.</p> <p>Loader delivers plugins from one or many plugin packages.</p>"},{"location":"reference/#gufo.loader--loader","title":"Loader","text":"<p>Loader is the dict-like singleton providing the following services:</p> <ul> <li>plugin initialization and fetching.</li> <li>plugins enumeration.</li> </ul> <p>Plugins are not dependent on the loader and do not need any registration process. The loaders are lazy by nature, meaning the plugin will be imported and initialized just in time when the user code requests the plugin.</p>"},{"location":"reference/#gufo.loader--plugins","title":"Plugins","text":"<p>Plugins are named entities dedicated to the given task. Each plugin is defined in its python module. Depending on the loader settings plugins can be:</p> <ul> <li>Instances: Singleton instances having the class as the ancestor.</li> <li>Subclasses: Classes having the common ancestor.</li> <li>Protocols: Classes following the set of methods.</li> </ul>"},{"location":"reference/#gufo.loader--plugin-packages","title":"Plugin Packages","text":"<p>Plugin packages are plain Python packages: the directory containing python files with plugins and the empty <code>__init__.py</code> file.</p> <p>Plugin name must match the module name. For example, module <code>my_plugin.py</code> will define the plugin <code>my_plugin</code>.</p> Example <p>Plugins as the subclasses:</p> <pre><code>loader = Loader[Type[BasePlugin]](base=\"myproject.plugins\")\n</code></pre> Example <p>Plugins as the singletones:</p> <pre><code>loader = Loader[BasePlugin](base=\"myproject.plugins\")\n</code></pre> Example <p>Plugins as the protocols:</p> <pre><code>loader = Loader[Type[MyProtocol]](base=\"myproject.plugins\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>__version__</code> <code>str</code> <p>Current version</p>"},{"location":"reference/#gufo.loader.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic loader. Used as singleton instantiated from generic.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Optional[str]</code> <p>Plugins package name.</p> <code>None</code> <code>bases</code> <code>Optional[Iterable[str]]</code> <p>Iterable of plugin package names.</p> <code>None</code> <code>strict</code> <code>bool</code> <p>Ignore missed plugin packages if set to False, Fail otherwise.</p> <code>False</code> <code>exclude</code> <code>Optional[Iterable[str]]</code> <p>Iterable of names to be excluded from plugins lists.</p> <code>None</code> Note <p><code>base</code> and <code>bases</code> parameters are mutually exclusive. Either <code>base</code> or <code>bases</code> must be provided.</p>"},{"location":"reference/#gufo.loader.Loader.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Get plugin by name.</p> <p>Returns plugin item depending on generic type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plugin.</p> required <p>Returns:</p> Type Description <code>T</code> <p>Plugin item depending on generic type.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if plugin is missed.</p>"},{"location":"reference/#gufo.loader.Loader.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over plugin names.</p> <p>Iterate over all existing plugin names. Shortland for</p> <pre><code>loader.keys()\n</code></pre> <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>Iterable of plugin names.</p>"},{"location":"reference/#gufo.loader.Loader.get","title":"<code>get(name, default=None)</code>","text":"<p>Get plugin by name.</p> <p>Return <code>default</code> value if plugin is missed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of plugin.</p> required <code>default</code> <code>Optional[T]</code> <p>Default value, if plugin is missed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Plugin item depending on generic type or default value.</p>"},{"location":"reference/#gufo.loader.Loader.items","title":"<code>items()</code>","text":"<p>Iterate the (<code>name</code>, <code>item</code>) tuples for all plugin items.</p> Return <p>Iterable of tuples of (<code>name</code>, <code>item</code>)</p> None <p><code>items()</code> will force plugin module loading and instantination.</p>"},{"location":"reference/#gufo.loader.Loader.keys","title":"<code>keys()</code>","text":"<p>Iterate over plugin name.</p> <p>Iterable yielding all existing plugin names.</p> <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>Iterable of strings with all plugin names.</p> Note <p><code>keys()</code> do not force plugin module loading and instantination.</p>"},{"location":"reference/#gufo.loader.Loader.values","title":"<code>values()</code>","text":"<p>Iterate all found plugin items.</p> <p>Returns:</p> Type Description <code>Iterable[T]</code> <p>Iterable of plugin items.</p> Note <p><code>values()</code> will force plugin module loading and instantination.</p>"},{"location":"dev/","title":"Gufo Loader: Developer's Guide","text":"<p>This section is intended for Gufo Loader developers and for entities,  including both individuals and companies, interested in contributing to the project.</p> <ul> <li>Developer's Environment</li> <li>Building and Testing</li> <li>Common Tasks</li> <li>Code Quality</li> <li>Code Base</li> <li>Contributing Guide</li> <li>Code of Conduct</li> <li>Supported Standards</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/","title":"Gufo Stack Code of Conduct","text":"<p>Gufo Stack are the tools built by people for people. We aim to create a respectful, collaborative, and constructive community where everyone can contribute to building better software.</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-rule","title":"The Rule","text":"<p>\u201cAnd as you wish that others would do to you, do so to them.\u201d</p> <p>-- Luke 6:31</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-note","title":"The Note","text":"<p>This principle is universal. Similar wisdom can be found in many traditions:</p> <ul> <li>Confucius: \u201cDo not impose on others what you do not wish for yourself.\u201d (Analects 15:24)</li> <li>Prophet Muhammad (peace be upon him): \u201cNone of you [truly] believes until he loves for his brother what he loves for himself.\u201d (Hadith, Sahih Muslim 45:71)</li> </ul> <p>That\u2019s all.</p>"},{"location":"dev/CONTRIBUTING/","title":"Types of contributions","text":"<p>You can contribute to the Gufo Labs projects in several way. This repo is a place to discuss and collaborate on GitHub! Our team is maintaining this repo to preserve our bandwidth, off topic conversations will be closed.</p>"},{"location":"dev/CONTRIBUTING/#discussions","title":"Discussions","text":"<p>Discussions are where we have conversations.</p> <p>If you'd like help troubleshooting a PR you're working on, have a great new idea, or want to share something amazing you've learned in our docs, join us in discussions.</p>"},{"location":"dev/CONTRIBUTING/#issues","title":"Issues","text":"<p>Issues are used to track tasks that contributors can help with. </p> <p>If you've found bug, or something in the content of the documentation that should be updated, search open issues to see if someone else has reported the same thing. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p>"},{"location":"dev/CONTRIBUTING/#pull-requests","title":"Pull requests","text":"<p>A pull request is a way to suggest changes in our repository.</p>"},{"location":"dev/codebase/","title":"Project's Code Base","text":"<p>The code base of the project has following structure:</p> <ul> <li><code>.devcontainer/</code> - Developer's container configuration for    VSCode Remote Containers. Just reopen   project in remote container to get ready-to-development   environment.</li> <li> <p><code>.github/</code> - GitHub settings</p> <ul> <li><code>workflows/</code> - GitHub Actions Workflows settings.   Used to run tests and build the documentation.</li> </ul> </li> <li> <p><code>docs/</code> - Mkdocs documentation.</p> </li> <li><code>examples/</code> - Project's examples.</li> <li><code>src/</code> - Project's source code.</li> <li><code>tests/</code> - Project's Pytest test suite.</li> <li><code>.gitignore</code> - Gitignore file.</li> <li><code>Dockerfile</code> - Dockerfile for development container.</li> <li><code>mkdocs.yml</code> - Mkdocs configuration file.</li> <li><code>pyproject.toml</code> - pyproject.toml file for python tools configuration.</li> </ul>"},{"location":"dev/codequality/","title":"Code Quality Guide","text":"<p>We share the common code quality standards between all Gufo Labs projects.</p>"},{"location":"dev/codequality/#python-code-formatting","title":"Python Code Formatting","text":"<p>All Python code must be formatting using ruff code formatter with settings defined in the project's <code>pyproject.toml</code> file.</p>"},{"location":"dev/codequality/#python-code-linting","title":"Python Code Linting","text":"<p>All Python code must pass ruff tests with the project's settings.</p>"},{"location":"dev/codequality/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>All python code must pass Mypy type checks in the <code>strict</code> mode.</p>"},{"location":"dev/codequality/#test-suite-coverage","title":"Test Suite Coverage","text":"<p>The test suite must provide 100% code coverage whenever possible.</p>"},{"location":"dev/codequality/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Documentation must be clean and mean.</li> </ul>"},{"location":"dev/common/","title":"Developer's Common  Tasks","text":""},{"location":"dev/common/#bump-version","title":"Bump Version","text":"<ul> <li> Change <code>__version__</code> in <code>src/gufo/loader/__init__.py</code></li> <li> Add section in <code>CHANGELOG.md</code></li> </ul>"},{"location":"dev/environment/","title":"Developer's Environment","text":"<p>To participate in development you need to prepare the developer's environment first. Depending on the preferable tools, your mileage may vary.</p>"},{"location":"dev/environment/#visual-studio-code-dev-container","title":"Visual Studio Code Dev Container","text":"<p>The easiest way to start the development is to use Visual Studio Code with Remote Containers plugin. Just click on the green sign in the lower-left corner and select the \"Reopen in Container\" menu item. You'll get all the required formatting and linting settings out of the box.</p>"},{"location":"dev/standards/","title":"Supported Standards","text":"<p>Gufo Loader implements and is guided by the following standards:</p>"},{"location":"dev/standards/#python-pep","title":"Python PEP","text":"<ul> <li>PEP8: Style Guide for Python Code</li> <li>PEP561: Distributing and Packaging Type Information</li> </ul>"},{"location":"dev/testing/","title":"Building and Testing","text":"<p>Before starting building and testing package set up  Developer's Environment first. From here and below we consider the shell's current directory matches the project's root directory.</p>"},{"location":"dev/testing/#building-package","title":"Building Package","text":"<p>To test the package build run:</p> <pre><code>$ python -m build --sdist --wheel\n</code></pre> <p>Compiled packages will be available in the <code>dist/</code> directory.</p>"},{"location":"dev/testing/#running-tests","title":"Running tests","text":"<p>To run the test suit:</p> <pre><code>$ pytest -vv\n</code></pre>"},{"location":"dev/testing/#running-lints","title":"Running Lints","text":"<p>All lints are checked as part of GitHub Actions Workflow. You may run lints manually before committing to the project.</p>"},{"location":"dev/testing/#check-formatting","title":"Check Formatting","text":"<p>Python Code Formatting is the mandatory requirement in our Code Quality standards. To check code formatting run:</p> <pre><code>$ ruff format --check examples/ src/ tests/\n</code></pre> <p>To fix formatting errors run: <pre><code>$ ruff format examples/ src/ tests/\n</code></pre></p> <p>We recommend setting python code formatting on file saving (Done in VS Code Dev Container out of the box).</p>"},{"location":"dev/testing/#python-code-lints","title":"Python Code Lints","text":"<p>Python Code Linting is the mandatory requirement in our Code Quality standards. To check code for linting errors run:</p> <pre><code>$ ruff check examples/ src/ tests/\n</code></pre>"},{"location":"dev/testing/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>Python Code Static Checks is the mandatory requirement in our Code Quality standards. To check code for typing errors run:</p> <pre><code>$ mypy --strict src/\n</code></pre>"},{"location":"dev/testing/#python-test-code-coverage-check","title":"Python Test Code Coverage Check","text":"<p>To evaluate code coverage run tests:</p> <pre><code>$ coverage run -m pytest -vv\n</code></pre> <p>To report the coverage after the test run:</p> <pre><code>$ coverage report\n</code></pre> <p>To show line-by-line coverage:</p> <pre><code>$ coverage html\n</code></pre> <p>Then open <code>dist/coverage/index.html</code> file in your browser.</p>"},{"location":"dev/testing/#building-documentation","title":"Building Documentation","text":"<p>To rebuild and check documentation run</p> <pre><code>$ mkdocs serve\n</code></pre> <p>We recommend using Grammarly service to check documentation for common errors.</p>"},{"location":"examples/","title":"Gufo Loader Examples","text":"<p>Consider the practical task. Let's write the simple integer calculator application. The application must be called from the command line, accept the operation name and two integer arguments, perform the operation and print the result.</p> <p>I.e.</p> <pre><code>$ python -m myapp add 1 2\n3\n</code></pre> <p>We'll learn 3 possible implementations, each with its own strong and weak sides:</p> <ul> <li>Subclasses of the given class.</li> <li>Classes sharing the protocol.</li> <li>Singleton instances of the given class.</li> </ul>"},{"location":"examples/protocol/","title":"Protocol Scheme","text":"<p>The protocol scheme is similar with the subclass one, except for one point: instead of using and inheriting the base class, we define the Protocol.</p> <p>Python typing protocols are the class signatures. Instead of defining the base class and inherit from it, we define the functions and their signatures.</p> <p>The major advantage of the protocol scheme is the fact we need no to import something from the core in our plugins.</p>"},{"location":"examples/protocol/#plugin-protocol","title":"Plugin Protocol","text":"<p>First, lets define the plugin's protocol</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>More complicated, then subclass, but still simple.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>We need <code>Protocol</code> and <code>runtime_checkable</code> from the Python <code>typing</code> module.</p> <p>base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <code>@runtime_checkable</code> decorator is necessary for Loader to be able to check plugins signatures. Do not forget it.</p> <p>base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> Protocols are derived from <code>Protocol</code> generic class.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>Though docstrings are advisory it will help to navigate our code, so describe plugin tasks and features.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>Our plugins has no initialization parameters, so we declare plain <code>__init__</code> constructor. All protocol functions are abstract, so we add <code>...</code> operator to skip the implementation.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>Our main function of the plugin, do not to forget to place the proper type hints to allow static type checking.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>The main function of the plugin already should be documented.</p> base.py<pre><code>from typing import Protocol, runtime_checkable\n\n\n@runtime_checkable\nclass PluginProtocol(Protocol):\n    \"\"\"Protocol for our plugin.\"\"\"\n\n    def __init__(self) -&gt; None: ...\n\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n        ...\n</code></pre> <p>Ellipses operator (<code>...</code>) shows the implementation is abstract.  If missed, mypy will complain the function doesn't return an integer value.</p>"},{"location":"examples/protocol/#application-core","title":"Application Core","text":"<p>Let's define the application's core.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Almost similar to the subclass core, except for the Loader type.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import the Python modules <code>sys</code> and <code>typing</code>. We need the <code>typing</code> to define the loader's type. <code>sys</code> is used to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>Loader</code> class.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>PluginProtocol</code> class to define <code>Loader</code> type.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then let's create a loader instance. You need only one loader instance per each type for your application. So loaders are usually singletons.</p> <p>Loader is the generic type, so we must pass the exact plugin type. In the protocol scheme plugins are classes, following from the <code>PluginProtocol</code> protocol. In Python's typing terms, the protocol type is the <code>Type[PluginProtocol]</code>. We'd placed the type into the brackets just after the <code>Loader</code>.</p> <p>Warning</p> <p>Note the protocol defines type, not an instance. This is why we need to use <code>Type[PluginProtocol]</code>, not <code>PluginProtocol</code>.</p> <p>After defining the plugin's type, we need to initialize the loader itself. Loader has several initialization parameters, see Reference for details. Here we consider our plugins will be in <code>plugins</code> folder of our applications.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Our <code>main</code> function accepts the operation's name and two integer arguments. Then it prints the result.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Loader supports dict-like interface to access the modules. For this example, we will  use bracket notation. We use <code>op</code> parameter as the plugin name.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Loader returns the class. We create the instance to show we can use some plugin initialization tasks. We can also define the <code>execute</code> method as a <code>@classmethod</code> to skip  the initialization step.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we call <code>execute</code> method of the plugin. Your editor must show the <code>r</code> variable has the type of <code>int</code></p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we print the result, and our core function is finally complete.</p> <p>__main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import PluginProtocol\n\nloader = Loader[Type[PluginProtocol]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> We're extracting our arguments directly from <code>sys.argv</code>. Then we call our core function. The core is complete.</p>"},{"location":"examples/protocol/#plugins","title":"Plugins","text":"<p>Next we need to implement plugins itself. First, create directory <code>plugins</code> for our plugins packages. Then add empty <code>__init__.py</code> file. </p> <p>We're ready to write our plugins.</p>"},{"location":"examples/protocol/#add-plugin","title":"add Plugin","text":"<p>Lets implement the plugin for adding numbers. Our plugin has the name <code>add</code>, so we're placing it into <code>add.py</code> file.</p> plugins/add.py<pre><code>class AddPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> <p>The code is pretty and clean and ever simple than subclass scheme.</p> <p>plugins/add.py<pre><code>class AddPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> Create the new plugin class. Class must follow <code>PluginProtocol</code> signature but we need no the point it explicitly. So we may derive our plugin from any class. Let's start from <code>object</code>.</p> <p>plugins/add.py<pre><code>class AddPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> Then override the <code>execute</code> function.</p> <p>plugins/add.py<pre><code>class AddPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> All we need is to add two numbers and return the result. Our plugin is complete.</p>"},{"location":"examples/protocol/#sub-plugin","title":"sub Plugin","text":"<p>Let's create another plugin for subtraction. Our plugin has the name <code>sub</code>, so we're placing it into <code>sub.py</code> file.</p> plugins/sub.py<pre><code>class SubPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n</code></pre> <p>Pretty like the <code>add</code> plugin, only the class name and implementation differ.</p> <p>plugins/sub.py<pre><code>class SubPlugin(object):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n</code></pre> All we need is to subtract two numbers and return the result. Our plugin is complete.</p>"},{"location":"examples/protocol/#testing","title":"Testing","text":"<pre><code>$ python3 -m myapp add 1 2\n3\n</code></pre> <pre><code>$ python3 -m myapp sub 2 1\n1\n</code></pre>"},{"location":"examples/protocol/#summary","title":"Summary","text":"<p>We have learned how to create simple and extendable applications using protocol-based approach.</p>"},{"location":"examples/singleton/","title":"Singleton Scheme","text":"<p>The singleton scheme is similar to the subclass one with the exception: Loader returns plugin instance, rather than class. Instance is initialized on the first load, and only one instance of plugin exists.</p> <p>We need the base class to define the scheme, then inherit the plugins.</p>"},{"location":"examples/singleton/#plugin-base","title":"Plugin Base","text":"<p>First, let's define the plugins base class just like in subclass scheme.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>The code is straightforward</p> <p>base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> In this module, we define an abstract class. It does not provide an actual implementation but rather specifies an interface. The established practice in Python is to derive such classes from <code>ABC</code> and mark the required parts with <code>@abstractmethod</code>.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Define a base class for our plugins. We have no particular requirements, so we can derive it from <code>ABC</code> to mark this class is abstract.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Though docstrings are advisory, it will help to navigate our code, so describe plugin tasks and features.</p> <p>base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> The <code>@abstractmethod</code> decorator indicates that a method must be implemented in derived classes.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Our main function of the plugin, do not to forget to place the proper type hints to allow static type checking.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>The main function of the plugin already should be documented.</p>"},{"location":"examples/singleton/#application-core","title":"Application Core","text":"<p>First, lets define the application's core:</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Lets explain the code:</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>Loader</code> class.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>PluginBase</code> class to define <code>Loader</code> type.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then let's create a loader instance. You need only one loader instance per each type for your application. So loaders are usually singletons.</p> <p>Loader is the generic type, so we must pass the exact plugin type. The instances of <code>BasePlugin</code> type has the <code>BasePlugin</code> type. We'd placed the type into the brackets just after the <code>Loader</code>.</p> <p>After defining the plugin's type, we need to initialize the loader itself. Loader has several initialization parameters, see Reference for details. Here we consider our plugins will be in <code>plugins</code> folder of our applications.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Our <code>main</code> function accepts the operation's name and two integer arguments. Then it prints the result.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Loader supports dict-like interface to access the modules. For this example, we will  use bracket notation. We use <code>op</code> parameter as the plugin name.  Unlike the subclass scheme, our loader returns the initialized instance directly.</p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we call <code>execute</code> method of the plugin. Your editor must show the <code>r</code> variable has the type of <code>int</code></p> __main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we print the result, and our core function is finally complete.</p> <p>__main__.py<pre><code>import sys\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[BasePlugin](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    item = loader[op]\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> We're extracting our arguments directly from <code>sys.argv</code>. Then we call our core function. The core is complete.</p>"},{"location":"examples/singleton/#plugins","title":"Plugins","text":"<p>Next we need to implement plugins itself. First, create directory <code>plugins</code> for our plugins packages. Then add empty <code>__init__.py</code> file. </p> <p>We're ready to write our plugins.</p>"},{"location":"examples/singleton/#add-plugin","title":"add Plugin","text":"<p>Lets implement the plugin for adding numbers. Our plugin has the name <code>add</code>, so we're placing it into <code>add.py</code> file.</p> plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> <p>The code is pretty and clean</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> Import the base class <code>BasePlugin</code>. Note, we use relative import to clean up our code.</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> Create new plugin class and inherit it from <code>BasePlugin</code>.</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> Then override the <code>execute</code> function.</p> plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> <p>All we need is to add two numbers and return the result.</p> plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> <p>Let's define a singleton. Our plugin is complete.</p>"},{"location":"examples/singleton/#sub-plugin","title":"sub Plugin","text":"<p>Let's create another plugin for subtraction. Our plugin has the name <code>sub</code>, so we're placing it into <code>sub.py</code> file.</p> plugins/sub.py<pre><code>from ..base import BasePlugin\n\n\nclass SubPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n\n\nsub_plugin = SubPlugin()\n</code></pre> <p>Pretty like the <code>add</code> plugin, only the class name and implementation differ.</p> <p>plugins/sub.py<pre><code>from ..base import BasePlugin\n\n\nclass SubPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n\n\nsub_plugin = SubPlugin()\n</code></pre> All we need is to subtract two numbers and return the result.</p> plugins/sub.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n\n\nadd_plugin = AddPlugin()\n</code></pre> <p>Let's define a singleton. Our plugin is complete.</p>"},{"location":"examples/singleton/#testing","title":"Testing","text":"<pre><code>$ python3 -m myapp add 1 2\n3\n</code></pre> <pre><code>$ python3 -m myapp sub 2 1\n1\n</code></pre>"},{"location":"examples/singleton/#summary","title":"Summary","text":"<p>We have learned how to create simple and extendable applications using singleton-base approach.</p>"},{"location":"examples/subclass/","title":"Subclass Scheme","text":"<p>The subclass scheme is the simplest to implement and to understand. We need the base class to define the scheme, then inherit the plugins.</p>"},{"location":"examples/subclass/#plugin-base","title":"Plugin Base","text":"<p>First, let's define the plugins base class:</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>The code is straightforward</p> <p>base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> In this module, we define an abstract class. It does not provide an actual implementation but rather specifies an interface. The established practice in Python is to derive such classes from <code>ABC</code> and mark the required parts with <code>@abstractmethod</code>.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Define a base class for our plugins. We have no particular requirements, so we can derive it from <code>ABC</code> to mark this class is abstract.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Though docstrings are advisory, it will help to navigate our code, so describe plugin tasks and features.</p> <p>base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> The <code>@abstractmethod</code> decorator indicates that a method must be implemented in derived classes.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>Our main function of the plugin, do not to forget to place the proper type hints to allow static type checking.</p> base.py<pre><code>from abc import ABC, abstractmethod\n\n\nclass BasePlugin(ABC):\n    \"\"\"Base class for our plugin.\"\"\"\n\n    @abstractmethod\n    def execute(self, x: int, y: int) -&gt; int:\n        \"\"\"Plugin performs operation on two integers and returns integer.\"\"\"\n</code></pre> <p>The main function of the plugin already should be documented.</p>"},{"location":"examples/subclass/#application-core","title":"Application Core","text":"<p>First, lets define the application's core:</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Lets explain the code:</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import the Python modules <code>sys</code> and <code>typing</code>. We need the <code>typing</code> to define the loader's type. <code>sys</code> is used to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>Loader</code> class.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Import <code>PluginBase</code> class to define <code>Loader</code> type.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then let's create a loader instance. You need only one loader instance per each type for your application. So loaders are usually singletons.</p> <p>Loader is the generic type, so we must pass the exact plugin type. In the subclass scheme plugins are classes, derived from the <code>BasePlugin</code> class. In Python's typing terms, the subclass of <code>BasePlugin</code> has the <code>Type[BasePlugin]</code> type. We'd placed the type into the brackets just after the <code>Loader</code>.</p> <p>After defining the plugin's type, we need to initialize the loader itself. Loader has several initialization parameters, see Reference for details. Here we consider our plugins will be in <code>plugins</code> folder of our applications.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Our <code>main</code> function accepts the operation's name and two integer arguments. Then it prints the result.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Loader supports dict-like interface to access the modules. For this example, we will  use bracket notation. We use <code>op</code> parameter as the plugin name.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Loader returns the class. We create the instance to show we can use some plugin initialization tasks. We can also define the <code>execute</code> method as a <code>@classmethod</code> to skip  the initialization step.</p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we call <code>execute</code> method of the plugin. Your editor must show the <code>r</code> variable has the type of <code>int</code></p> __main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> <p>Then we print the result, and our core function is finally complete.</p> <p>__main__.py<pre><code>import sys\nfrom typing import Type\n\nfrom gufo.loader import Loader\n\nfrom .base import BasePlugin\n\nloader = Loader[Type[BasePlugin]](base=\"myapp.plugins\")\n\n\ndef main(op: str, x: int, y: int) -&gt; None:\n    kls = loader[op]\n    item = kls()\n    r = item.execute(x, y)\n    print(r)\n\n\nmain(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))\n</code></pre> We're extracting our arguments directly from <code>sys.argv</code>. Then we call our core function. The core is complete.</p>"},{"location":"examples/subclass/#plugins","title":"Plugins","text":"<p>Next we need to implement plugins itself. First, create directory <code>plugins</code> for our plugins packages. Then add empty <code>__init__.py</code> file. </p> <p>We're ready to write our plugins.</p>"},{"location":"examples/subclass/#add-plugin","title":"add Plugin","text":"<p>Lets implement the plugin for adding numbers. Our plugin has the name <code>add</code>, so we're placing it into <code>add.py</code> file.</p> plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> <p>The code is pretty and clean</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> Import the base class <code>BasePlugin</code>. Note, we use relative import to clean up our code.</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> Create new plugin class and inherit it from <code>BasePlugin</code>.</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> Then override the <code>execute</code> function.</p> <p>plugins/add.py<pre><code>from ..base import BasePlugin\n\n\nclass AddPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x + y\n</code></pre> All we need is to add two numbers and return the result. Our plugin is complete.</p>"},{"location":"examples/subclass/#sub-plugin","title":"sub Plugin","text":"<p>Let's create another plugin for subtraction. Our plugin has the name <code>sub</code>, so we're placing it into <code>sub.py</code> file.</p> plugins/sub.py<pre><code>from ..base import BasePlugin\n\n\nclass SubPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n</code></pre> <p>Pretty like the <code>add</code> plugin, only the class name and implementation differ.</p> <p>plugins/sub.py<pre><code>from ..base import BasePlugin\n\n\nclass SubPlugin(BasePlugin):\n    def execute(self, x: int, y: int) -&gt; int:\n        return x - y\n</code></pre> All we need is to subtract two numbers and return the result. Our plugin is complete.</p>"},{"location":"examples/subclass/#testing","title":"Testing","text":"<pre><code>$ python3 -m myapp add 1 2\n3\n</code></pre> <pre><code>$ python3 -m myapp sub 2 1\n1\n</code></pre>"},{"location":"examples/subclass/#summary","title":"Summary","text":"<p>We have learned how to create simple and extendable applications using subclass-based approach.</p>"}]}